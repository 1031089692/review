今日内容
    1、操作系统/应用程序
    2、操作中的'并发'
    3、其他语言的线程、进程
    4、python中线程和进程（GIL锁）
    5、python线程编写+锁
    6、小爬虫


并发和并行
    并发：伪，指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使得在宏观上具有多个进程同时执行的效果，
        但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行。
    并行：真，指在同一时刻，有多条指令在多个处理器上同时执行。所以无论从微观还是从宏观来看，二者都是一起执行的。

线程和进程
    线程：
        工作的最小单元
        共享进程中左右的资源
        每个线程可以分担一些任务，最终完成最后的结果
    进程：
        独立开辟内存
        进程之间的数据隔离

python的GIL锁，全局解释器锁：限制一个进程中，同一时刻，只有一个线程能被cpu调度。
    扩展:默认GIL锁在执行100个cpu指令(过期时间)


python多线程情况下：
    - 计算密集型操作:效率低。(GIL锁)
    - IO操作:效率高(IO操作不占用CPU)
python多进程情况下：
    - 计算密集型操作:效率高。(浪费资源)
    - IO操作:效率高（浪费资源）
写python时：
    IO密集型用多线程    文件/输入输出/socket通信/爬虫
    计算密集型用多进程


python多线程的锁(初始的总结)
    自己加的锁和GIL锁的区别。GIL锁是限制一个进程同一时刻，只能有一个线程被cpu调度。自己加的锁，是让自己的这个线程加锁的这一段跑完
    才能切换到下一个线程。



总结：
    1、python中存在一个GIL锁
        造成：多线程无法利用多核优势
        解决：开多进程处理(浪费资源)

    2、线程的创建
        Thread
        MyThread----继承---不常用

    3、线程常用操作
        join    控制主线程等待子线程时间
        setDeanon 设置为Ture，主线程不会等待子线程
        setName   设置线程名字
        threading.current_thread()  获取当前线程的对象

    4、锁   lock = threading.RLock()
        获得    lock.acquire()  # 加锁
        释放    lock.release()    # 释放锁